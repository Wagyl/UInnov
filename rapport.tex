%% LyX 2.0.5.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[french]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{verbose}
\usepackage{babel}
\makeatletter
\addto\extrasfrench{%
   \providecommand{\og}{\leavevmode\flqq~}%
   \providecommand{\fg}{\ifdim\lastskip>\z@\unskip\fi~\frqq}%
}

\makeatother
\begin{document}

\title{Projet de Programmation Comparée : ''Interfaces Utilisateurs''}

\maketitle

\section{Qu'est ce qu'une interface utilisateur et comment en programmer}


\subsection{Définition des concepts liés à la notion d'interface utilisateur}


\subsubsection*{Qui sont les utilisateurs ?}

Avant toute analyse ou réflexion, il est important de définir qui
sont les utilisateurs du système considéré.
\begin{itemize}
\item Deux catégories : nous utiliserons la terminologie suivante afin de
distinguer les deux catégories d'utilisateurs : utilisateur application,
et programmeur.
\item Dans les deux cas, il faut avoir une approche orientée utilisateur,
les besoins seront différents, mais l'approche à adopter la même. 
\item Utilisateur application : il faut prendre en compte à la fois l'aspect
sensoriel (visuel si écran il y a) et l'aspect ``contrôle'' (gestion
des périphériques d'entrée).
\item Interaction utilisateur application - programme : plusieurs ``niveaux''
de compétences parmi les utilisateurs avec des besoins différents.
\end{itemize}

\subsubsection*{Conception - génie logiciel}

La conception d'une interface utilisateur doit être centrée autour
des deux catégories d'acteurs définies précédemment, l'utilisation
du modèle de conception centré utilisateur semble alors tout à fait
correspondre aux besoins.

Ce dernier est itératif, chaque itération étant composée des trois
phases suivantes :
\begin{itemize}
\item \textbf{Analyse :} on analyse les besoins des acteurs du système,
un panel représentatif d'utilisateurs des deux catégories concernées
doit être constitué afin d'établir les dits besoins.
\item \textbf{Conception :} un prototype doit être conçu en fonction des
besoins établis à l'étape précédente. Chaque prototype servira le
plus souvent de base à celui à l'étape suivante
\item \textbf{Évaluation :} sur la base du prototype réalisé, une évaluation
est faite. Le procédé étant itératif, cette évaluation servira de
base à la modification des besoins de la première étape de l'itération
suivante. 
\end{itemize}
Afin de mener à bien ces trois phases, il est nécessaire d'établir
des critères d'évaluation qui serviront aussi de base à l'élaboration
des besoins. L'utilisateur application doit être pris en compte même
s'il sera la cible du système développé par le programmeur et non
directement la cible du notre. Ses besoins doivent nous permettre
de mieux déterminer ce dont ont besoin les programmeurs pour satisfaire
aux exigences des utilisateurs application.
\begin{itemize}
\item Pour l'utilisateur application :

\begin{itemize}
\item Vitesse d'apprentissage - aide nécessaire / intégrée - nombre d'erreurs
commises lors d'un test.
\item Correction des erreurs.
\item Temps de réponse.
\item Efficacité - navigation rapide ?
\end{itemize}
\item Pour le programmeur :

\begin{itemize}
\item Programmation intuitive.
\item Bonne expressivité - ne pas avoir un code verbeux à produire (capacité
d'adaptation au support etc etc ?).
\item Typage fort - sûreté.
\item Debugging aisé - analyse de pertinence (détecter le maximum d'absurdités)
\item Intégration aux IDE populaires ? Création d'un IDE ?
\end{itemize}
\item \textbf{Les outils :} tout au long de ce processus de conception,
des outils du génie logiciel vont nous aider.

\begin{itemize}
\item Scénarios / diagrammes de cas d'utilisation : leur utilisation, combinée
aux critères mis en place ci-dessus, nous permettra à la fois d'établir
les besoins et d'effectuer des tests choisis dans le cadre de l'évaluation. 
\item Diagrammes relationnels - diagrammes de classes : même si elle ne
doit pas nous aveugler, la programmation orientée objet est adaptée
au sujet. La réflexion à mener quant à l'organisation du système considéré
se prête remarquablement bien à l'utilisation de ces outils. De plus,
ils nous permettent, à un autre niveau, de nous mettre à la place
du programmeur qui devra concevoir une interface en utilisant notre
système.
\item Design pattern : l'implémentation ``native'' de comportements génériques,
typiquement pour les interactions entre l'utilisateur application
et l'interface créée, permet à la fois de faciliter l'utilisation
de notre système par le programmeur mais aussi d'établir un cadre
sûr pour les les dites interactions. La partie 3.1 de ce rapport est
un exemple de ce principe.
\end{itemize}
\end{itemize}

\subsection{Division du travail}

La conception d'une interface graphique par dessus un moteur d'application
peut se diviser en quatre étapes ; une bibliothèque graphique devrait
fournir des outils adéquats pour chacune, et minimiser les interdépendances
entre elles.


\paragraph{Communication entre le moteur et l'interface}

Une bibliothèque graphique doit fournir des outils adaptées à la \og communication \fg{}
entre l'interface et le moteur logique de l'application
\begin{itemize}
\item affichage : ensemble des données du moteur affichées (sous diverses
formes) par l'interface ;
\item actions : ensemble des actions de l'utilisateur modifiant l'état des
données. 
\end{itemize}
Cette partie du code pose les bases de ce qu'utilisera l'interface,
ce à quoi elle est destinée, mais doit demeurer indépendante de son
implémentation réelle, des éléments graphiques concrets utilisés pour
la fabriquer, et de la plateforme à laquelle elle est destinée.


\paragraph{Éléments de l'interface}

Il s'agit ensuite de définir les éléments de l'interface graphique
qui serviront de support aux données et possibilités définis précédemment
; ceux-ci devront donc interagir avec le système logique de communication,
et non directement avec le moteur de l'application.

Ils sont évidemment dépendants de la plateforme à laquelle l'interface
est destinée : les raccourcis clavier d'un ordinateur seront remplacés
par des gestes tactiles sur une tablette, par exemple.\\


La bibliothèque se doit de définir un panel aussi vaste que possible
d'éléments graphique à disposition du développeur.

Notons que ces éléments ne sont pas forcément tous graphiques (lecture
d'un texte ou commande vocale).


\paragraph{Placement des éléments}

Les éléments doivent ensuite être assemblés pour former une interface
cohérente et fonctionnelle. À cette fin, de nombreux outils doivent
être présents pour le développeur : divers \og layout \fg{} permettant
diverses dispositions des éléments au sein d'une même fenêtre, gestion
intelligente des redimensionnements, système d'onglets, éléments permettant
le zoom et défilement, fenêtres pop-up, panneaux d'options, etc.

Une telle configuration s'effectue évidemment sur un ensemble d'éléments
de l'interface déjà défini, dont la taille et l'aspect graphique doivent
également pouvoir être éventuellement personnalisés au cas par cas.\\


Par ailleurs, le développeur peut laisser une partie de cette configuration
de l'interface à disposition de l'utilisateur final : lui permettre
de choisir les éléments présents d'une barre d'outils, ou le placement
de celle-ci sur certains bords de la fenêtre, tout en excluant certaines
autres modifications, le menu restant toujours identique.

Enfin, la forme finale d'une interface doit pouvoir être aisément
enregistrée, et il doit être possible pour l'utilisateur final de
passer d'une configuration à une autre s'il en existe plusieurs possibles
pour une application donnée.


\paragraph{Aspect général}

Enfin, la bibliothèque peut permettre au développeur de modifier l'aspect
général de son interface, en personnalisant l'aspect d'un type d'éléments
graphiques. Cette dernière partie est optionnel, mais si la possibilité
existe, elle doit être indépendante des trois premières : modifier
l'aspect général des boutons ne doit pas impacter le code de l'interface
déjà écrite.


\section{Analyse de l'existant}

Analyse de Swing / GTK (qui ont évidement des problèmes insurmontables)
ainsi que du couple HTML CSS et le concept intéressant de la séparation
du style de la déclaration des objets.


\section{Outils à développer}


\subsection{Actions}

Une librairie graphique se doit de fournir une représentation des
\emph{actions} que l'utilisateur peut accomplir. Fondamentalement,
il s'agit d'une fonction qui a accès au moteur de l'application, contrairement
à l'interface proprement dite, mais d'autres mécanismes internes s'y
greffent.

Ces \emph{actions} sont indépendantes des éléments graphiques concrets
qui l'implémentent, et donc en particulier de la plateforme sur laquelle
tourne l'interface utilisateur.

Toute intervention de l'utilisateur final sur le système de l'application
doit passer par une \emph{action} telle que définie par la librairie.\\


Deux principes nous guident :
\begin{itemize}
\item La façon dont l'utilisateur accomplit cette action n'a aucune importance
; l'action n'a pas besoin de savoir qu'elle a été déclenchée par un
bouton, une entrée de menu, un raccourci clavier, une commande vocale,
ou même comme conséquence automatique d'une autre action.
\item Tous les paramètres des éléments graphiques liés à une action doivent
être \og transférés \fg{} à l'action si possible, tels que :

\begin{itemize}
\item les raccourcis claviers, noms, descriptions, textes d'aide ou icônes
associés à une action ;
\item la possibilité d'accomplir l'action (qui déterminera si le bouton
ou l'entrée de menu sont actifs ou non, par exemple).
\end{itemize}
\end{itemize}
~

Ce mécanisme d'action fourni par la librairie graphique doit être
doté d'un pattern \og observer \fg{}, permettant à d'autres éléments
d'être notifié du déclenchement de l'action.

Les actions doivent pouvoir être aisément composées, afin de permettre
au développeur de n’implémenter que les interactions minimales avec
son système, tout en proposant à l'utilisateur final des fonctionnalités
simples autant qu'avancés, résultant éventuellement de combinaisons
complexes de ces briques de base.

Enfin, les actions effectuées doivent pouvoir être enregistrées, afin
d'en conserver un historique. Idéalement, si chaque action dispose
également d'une fonction \og inverse \fg{} permettant d'annuler
ses effets, la bibliothèque graphique peut fournir elle-même la fonctionnalité
\og undo / redo \fg{}, aujourd'hui devenue indispensable à toute
interface moderne.


\subsection{Bindings}

Très souvent, l'intervention de l'utilisateur modifie des valeurs
internes au moteur de l'application ; parfois néanmoins, l'inverse
peut être également utile : la modification d'une valeur du moteur
de l'application modifie l'état d'un élément de l'interface. Il s'agit
alors de modéliser efficacement la liaison d'une propriété d'un élément
graphique à une valeur de la logique interne de l'application.\\


Voici quelques exemples qui pourraient se révéler utiles au développement
d'une interface :
\begin{itemize}
\item progression d'une opération affichée par une barre de progression
;
\item possibilité d'effectuer une action liée à un booléen, impliquant l'apparence
des éléments graphiques qui lui sont liés (actifs ou non) ;
\item champs d'un label liée à une chaîne de caractère, position d'un curseur
liée à une valeur numérique ;
\item contenu d'un panneau lié à une image dynamiquement déterminée par
le moteur applicatif.\\

\end{itemize}
Si l’élément graphique peut être édité par l'utilisateur, la liaison
doit être effective dans les deux sens : le changement du champs du
label par l'utilisateur doit modifier la valeur de la chaîne de caractère
en interne, tout autre changement de la valeur doit être immédiatement
répercuté dans l'affichage, comme dans le cas de la barre d'url des
navigateurs internet (qui est évidemment actualisé en cas de redirection,
ou si l'utilisateur utilise un autre moyen pour parvenir sur un page
web).\\


À cette fin, la librairie graphique peut proposer des représentations
des types simples \og pertinents \fg{} comprenant un pattern observer
à destination des éléments de l'interface ; la liaison d'une propriété
graphique à la valeur deviendrait alors immédiate et transparente
pour le développeur. 

L'inconvénient est que le moteur de l'application doit alors utiliser
la librairie graphique pour implémenter de telles valeurs.


\subsection{Le modèle relationnel}

Les différents élément d'une interface utilisateur doivent être mis
en relation les uns avec les autres afin de former un tout cohérent.
Le principe le plus basique, qui est celui du modèle à widget évoqué
dans la partie 2, est de ne considérer qu'une seule relation : la
relation de parenté entre le contenant et le contenu.

Il serait cependant intéressant de pouvoir définir plus finement les
relations entre ces différents éléments, plus précisément, l'idée
serait de ne pas avoir à décrire l'emplacement d'un élément par rapport
à un autre, mais plutôt les relations entre ces éléments, un peu à
la manière du couple HTML / CSS.

Un premier exemple de relation autre qu'une relation de parenté est
la relation \og menu \fg{} qui est, à un niveau basique, présente
dans Swing : pour certains éléments il est possible de définir un
menu sans avoir à spécifier que ce dernier est contenu dans l'élément
demandeur. Il y a une relation de \og menu \fg{} entre ces deux
éléments et non une relation directe de positionnement.

Ce modèle a pour but de permettre à l'interface produite de s'adapter
à son environnement d'utilisation. De plus, une analyse statique de
la cohérence d'une interface pourrait certainement se faire à partir
d'un tel modèle (réflexion en cours).


\subsection{Langages intermédiaires}

Le système a vocation à être porté sur différents langages de programmation;
l'utilisation de langages intermédiaires, propres au dit système,
permet entre autre une portabilité intéressante. Deux langages intermédiaires
sont introduit à cet effet :
\begin{itemize}
\item Style de l'interface : notre solution à base de modèle relationnel
doit être complétée, afin d'obtenir l'adaptativité recherchée, d'une
déclaration de style dont le rôle est de traduire les relations entre
les composants en une présentation graphique adaptée au support. Ceci
nécessite d'une part l'élaboration d'un langage intermédiaire servant
à décrire cette traduction et d'autre part la réalisation d'un interpréteur
du dit langage. L'utilisation d'une telle architecture permet à la
fois d'avoir un comportement par défaut propre à chaque support, mais
peut aussi permettre au programmeur d’établir une charte graphique
pour toutes ses applications, et ce sans avoir à s'en préoccuper à
chaque nouveau projet.
\item Structure de l'interface : une autre volonté de notre part est de
permettre la sauvegarde de la structure d'une interface. Avoir une
description de ladite structure non liée à langage source permet une
réutilisation intéressante sur différents projets. La difficulté d'une
telle représentation se situe au niveau des interactions entre le
moteur de l'application et l'interface utilisateur, cependant le modèle
d'actions est adapté à cette démarche (cette partie est encore floue,
nous sommes encore en phase de réflexion quant à la faisabilité et
la pertinence de la chose).\end{itemize}

\end{document}
