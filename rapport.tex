%% LyX 2.0.5.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[french]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{verbose}
\usepackage{babel}
\makeatletter
\addto\extrasfrench{%
   \providecommand{\og}{\leavevmode\flqq~}%
   \providecommand{\fg}{\ifdim\lastskip>\z@\unskip\fi~\frqq}%
}

\makeatother
\begin{document}

\title{Projet de Programmation Comparée : ''Interfaces Utilisateurs''}

\maketitle

\section{Qu'est ce qu'une interface utilisateur et comment en programmer}


\subsection{Définition des concepts liés à la notion d'interface utilisateur}


\subsubsection*{Qui sont les utilisateurs ?}
\begin{itemize}
\item Deux catégories : nous utiliserons la terminologie suivante afin de
distinguer les deux catégories d'utilisateurs : utilisateur application,
et programmeur.
\item Dans les deux cas, il faut avoir une approche orientée utilisateur,
les besoins seront différents, mais l'approche à adopter la même. 
\item Utilisateur application : il faut prendre en compte à la fois l'aspect
sensoriel (visuel si écran il y a) et l'aspect ``contrôle'' (gestion
des périphériques d'entrée).
\item Interaction utilisateur application - programme : plusieurs ``niveaux''
de compétences parmi les utilisateurs avec des besoins différents.
\end{itemize}

\subsubsection*{Conception - génie logiciel}

Utilisation de la conception centrée utilisateur qui est un modèle
itératif.
\begin{itemize}
\item \textbf{Analyse :} analyse des besoins, un panel représentatif d'utilisateurs
des deux catégories concernées doit être constitué afin d'établir
les dits besoins.
\item \textbf{Conception :} un prototype doit être conçu en fonction des
besoins établis à l'étape précédente.
\item \textbf{Évaluation :} sur la base du prototype réalisé, une évaluation
est faite. Le procédé étant itératif, cette évaluation servira de
base à la modification des besoins de la première étape. 
\item Il faut établir des ``topic'' d'évaluation - besoins, les deux sont
liés : 

\begin{itemize}
\item Pour l'utilisateur application :

\begin{itemize}
\item Vitesse d'apprentissage - aide nécessaire / intégrée - nombre d'erreurs
commises lors d'un test.
\item Correction des erreurs.
\item Temps de réponse.
\item Efficacité - navigation rapide ?
\end{itemize}
\item Pour le programmeur :

\begin{itemize}
\item Programmation intuitive.
\item Bonne expressivité - ne pas avoir un code verbeux à produire (capacité
d'adaptation au support etc etc ?).
\item Typage fort - sûreté.
\item Debugging aisé - analyse de pertinence (détecter le maximum d'absurdités)
\item Intégration aux IDE populaires ? Création d'un IDE ?
\end{itemize}
\end{itemize}
\item \textbf{Les outils : }des outils du génie logiciel peuvent nous aider
à l'intérieur des phases décrites précédemment :

\begin{itemize}
\item Scénarios / diagrammes de cas d'utilisation : à la fois pour établir
les besoins et faire l'évaluation au niveau de l'utilisateur application.
Peut aussi être utilisé pour le côté programmeur bien que le point
suivant me semble être plus approprié.
\item Diagrammes relationnels - diagrammes de classes : relations entre
les différents objets de l'interface, est utile dans la phase de conception
pour ``se mettre à la place'' du programmeur.
\item Design pattern : beaucoup d'interfaces utilisateurs utilisent des
principes similaires d’interaction avec l'utilisateur, l'implémentation
``native'' de comportements génériques peut être pratique.
\end{itemize}
\end{itemize}

\subsection{Division du travail}

La conception d'une interface graphique par dessus un moteur d'application
peut se diviser en quatre parties qui devraient demeurer indépendantes
le plus possible.
\begin{itemize}
\item Communication entre le moteur et l'interface :

\begin{itemize}
\item Affichage : ensemble des données du moteur affichées (sous diverse
forme) par l'interface ;
\item Actions : ensemble des actions de l'utilisateur modifiant l'état du
moteur. Tout élément de l'interface permettant d'agir sur le moteur
devrait être lié à une ''Action''. Une même Action doit pouvoir
être effectuée par différents éléments d'une interface, et par différentes
interfaces.
\end{itemize}

Cette section doit être indépendante de l'interface finale (éléments,
aspect, etc) et de la plateforme.

\item Éléments de l'interface ; dépendant de la plateforme, lié à la partie
précédente.
\item Personnalisation des éléments : positionnement, taille, aspect...


Une telle configuration est évidemment dépendante de la partie précédente.


Certains paramètres de cette configuration doivent pouvoir être modifiés
par l'utilisateur final.


Ces configurations doivent pouvoir être enregistrées et s'échanger
facilement.

\item Aspect général.
\end{itemize}

\section{Analyse de l'existant}

Analyse de Swing / GTK (qui ont évidement des problèmes insurmontables)
ainsi que du couple HTML CSS et le concept intéressant de la séparation
du style de la déclaration des objets.


\section{Outils à développer}


\subsection{Actions}

Une librairie graphique se doit de fournir une représentation des
\emph{actions} que l'utilisateur peut accomplir. Fondamentalement,
il s'agit d'une fonction qui a accès au moteur de l'application, contrairement
à l'interface proprement dite, mais d'autres mécanismes internes s'y
greffent.

Ces \emph{actions} sont indépendantes des éléments graphiques concrets
qui l'implémentent, et donc en particulier de la plateforme sur laquelle
tourne l'interface utilisateur.

Toute intervention de l'utilisateur final sur le système de l'application
doit passer par une \emph{action} telle que définie par la librairie.\\


Deux principes nous guident :
\begin{itemize}
\item La façon dont l'utilisateur accomplit cette action n'a aucune importance
; l'action n'a pas besoin de savoir qu'elle a été déclenchée par un
bouton, une entrée de menu, un raccourci clavier, une commande vocale,
ou même comme conséquence automatique d'une autre action.
\item Tous les paramètres des éléments graphiques liés à une action doivent
être \og transférés \fg{} à l'action si possible, tels que :

\begin{itemize}
\item les raccourcis claviers, noms, descriptions, textes d'aide ou icônes
associés à une action ;
\item la possibilité d'accomplir l'action (qui déterminera si le bouton
ou l'entrée de menu sont actifs ou non, par exemple).
\end{itemize}
\end{itemize}
~

Ce mécanisme d'action fourni par la librairie graphique doit être
doté d'un pattern \og observer \fg{}, permettant à d'autres éléments
d'être notifié du déclenchement de l'action.

Les actions doivent pouvoir être aisément composées, afin de permettre
au développeur de n’implémenter que les interactions minimales avec
son système, tout en proposant à l'utilisateur final des fonctionnalités
simples autant qu'avancés, résultant éventuellement de combinaisons
complexes de ces briques de base.

Enfin, les actions effectuées doivent pouvoir être enregistrées, afin
d'en conserver un historique. Idéalement, si chaque action dispose
également d'une fonction \og inverse \fg{} permettant d'annuler
ses effets, la bibliothèque graphique peut fournir elle-même la fonctionnalité
\og undo / redo \fg{}, aujourd'hui devenue indispensable à toute
interface moderne.


\subsection{Bindings}

Liaison d'une propriété d'un élément de l'interface graphique à une
valeur du moteur de l'application : par exemple, la ''clickabilité''
(oui) d'un bouton à un booléen, le champs d'un label à une chaîne
de caractères, la valeur d'un curseur à une valeur du moteur logique,
le contenu d'un panel à une image...

La liaison doit être effective dans les deux sens : le changement
du champs du label par l'utilisateur doit modifier la valeur de la
chaîne de caractère, tout changement tiers de la valeur doit être
répercuté dans le label de l'interface.\\


Solution : la librairie fournit à l'intention du moteur de l'application
des classes pour des types simples comprenant un pattern observer
à destination des éléments de l'interface. 


\subsection{Le modèle relationnel}

Les différents élément d'une interface utilisateur doivent être mis
en relation les uns avec les autres afin de former un tout cohérent.
Le principe le plus basique, qui est celui du modèle à widget évoqué
dans la partie 2, est de ne considérer qu'une seule relation : la
relation de parenté entre le contenant et le contenu.

Il serait cependant intéressant de pouvoir définir plus finement les
relations entre ces différents éléments, plus précisément, l'idée
serait de ne pas avoir à décrire l'emplacement d'un élément par rapport
à un autre, mais plutôt les relations entre ces éléments, un peu à
la manière du couple HTML / CSS.

Un premier exemple de relation autre qu'une relation de parenté est
la relation \og menu \fg{} qui est, à un niveau basique, présente
dans Swing : pour certains éléments il est possible de définir un
menu sans avoir à spécifier que ce dernier est contenu dans l'élément
demandeur. Il y a une relation de \og menu \fg{} entre ces deux
éléments et non une relation directe de positionnement.

Ce modèle a pour but de permettre à l'interface produite de s'adapter
à son environnement d'utilisation. De plus, une analyse statique de
la cohérence d'une interface pourrait certainement se faire à partir
d'un tel modèle (réflexion en cours).


\subsection{Langages intermédiaires}

Plus approprié ici, à compléter entre autre quand l'idée d'un interpréteur
pour le visuel de l'interface aura été tranchée.
\end{document}
