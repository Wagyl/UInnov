#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language french
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Projet de Programmation Comparée : 
\begin_inset Quotes sld
\end_inset

Interfaces Utilisateurs
\begin_inset Quotes srd
\end_inset


\end_layout

\begin_layout Section
Qu'est ce qu'une interface utilisateur et comment en programmer
\end_layout

\begin_layout Subsection
Définition des concepts liés à la notion d'interface utilisateur
\end_layout

\begin_layout Subsubsection*
Qui sont les utilisateurs ?
\end_layout

\begin_layout Standard
Avant toute analyse ou réflexion, il est important de définir qui sont les
 utilisateurs du système considéré.
\end_layout

\begin_layout Itemize
Deux catégories : nous utiliserons la terminologie suivante afin de distinguer
 les deux catégories d'utilisateurs : utilisateur application, et programmeur.
\end_layout

\begin_layout Itemize
Dans les deux cas, il faut avoir une approche orientée utilisateur, les
 besoins seront différents, mais l'approche à adopter la même.
 
\end_layout

\begin_layout Itemize
Utilisateur application : il faut prendre en compte à la fois l'aspect sensoriel
 (visuel si écran il y a) et l'aspect 
\begin_inset Quotes eld
\end_inset

contrôle
\begin_inset Quotes erd
\end_inset

 (gestion des périphériques d'entrée).
\end_layout

\begin_layout Itemize
Interaction utilisateur application - programme : plusieurs 
\begin_inset Quotes eld
\end_inset

niveaux
\begin_inset Quotes erd
\end_inset

 de compétences parmi les utilisateurs avec des besoins différents.
\end_layout

\begin_layout Subsubsection*
Conception - génie logiciel
\end_layout

\begin_layout Standard
La conception d'une interface utilisateur doit être centrée autour des deux
 catégories d'acteurs définies précédemment, l'utilisation du modèle de
 conception centré utilisateur semble alors tout à fait correspondre aux
 besoins.
\end_layout

\begin_layout Standard
Ce dernier est itératif, chaque itération étant composée des trois phases
 suivantes :
\end_layout

\begin_layout Itemize

\series bold
Analyse :
\series default
 on analyse les besoins des acteurs du système, un panel représentatif d'utilisa
teurs des deux catégories concernées doit être constitué afin d'établir
 les dits besoins.
\end_layout

\begin_layout Itemize

\series bold
Conception :
\series default
 un prototype doit être conçu en fonction des besoins établis à l'étape
 précédente.
 Chaque prototype servira le plus souvent de base à celui à l'étape suivante
\end_layout

\begin_layout Itemize

\series bold
Évaluation :
\series default
 sur la base du prototype réalisé, une évaluation est faite.
 Le procédé étant itératif, cette évaluation servira de base à la modification
 des besoins de la première étape de l'itération suivante.
 
\end_layout

\begin_layout Standard
Afin de mener à bien ces trois phases, il est nécessaire d'établir des critères
 d'évaluation qui serviront aussi de base à l'élaboration des besoins.
 L'utilisateur application doit être pris en compte même s'il sera la cible
 du système développé par le programmeur et non directement la cible du
 notre.
 Ses besoins doivent nous permettre de mieux déterminer ce dont ont besoin
 les programmeurs pour satisfaire aux exigences des utilisateurs application.
\end_layout

\begin_layout Itemize
Pour l'utilisateur application :
\end_layout

\begin_deeper
\begin_layout Itemize
Vitesse d'apprentissage - aide nécessaire / intégrée - nombre d'erreurs
 commises lors d'un test.
\end_layout

\begin_layout Itemize
Correction des erreurs.
\end_layout

\begin_layout Itemize
Temps de réponse.
\end_layout

\begin_layout Itemize
Efficacité - navigation rapide ?
\end_layout

\end_deeper
\begin_layout Itemize
Pour le programmeur :
\end_layout

\begin_deeper
\begin_layout Itemize
Programmation intuitive.
\end_layout

\begin_layout Itemize
Bonne expressivité - ne pas avoir un code verbeux à produire (capacité d'adaptat
ion au support etc etc ?).
\end_layout

\begin_layout Itemize
Typage fort - sûreté.
\end_layout

\begin_layout Itemize
Debugging aisé - analyse de pertinence (détecter le maximum d'absurdités)
\end_layout

\begin_layout Itemize
Intégration aux IDE populaires ? Création d'un IDE ?
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Les outils :
\series default
 tout au long de ce processus de conception, des outils du génie logiciel
 vont nous aider.
\end_layout

\begin_deeper
\begin_layout Itemize
Scénarios / diagrammes de cas d'utilisation : leur utilisation, combinée
 aux critères mis en place ci-dessus, nous permettra à la fois d'établir
 les besoins et d'effectuer des tests choisis dans le cadre de l'évaluation.
 
\end_layout

\begin_layout Itemize
Diagrammes relationnels - diagrammes de classes : même si elle ne doit pas
 nous aveugler, la programmation orientée objet est adaptée au sujet.
 La réflexion à mener quant à l'organisation du système considéré se prête
 remarquablement bien à l'utilisation de ces outils.
 De plus, ils nous permettent, à un autre niveau, de nous mettre à la place
 du programmeur qui devra concevoir une interface en utilisant notre système.
\end_layout

\begin_layout Itemize
Design pattern : l'implémentation 
\begin_inset Quotes eld
\end_inset

native
\begin_inset Quotes erd
\end_inset

 de comportements génériques, typiquement pour les interactions entre l'utilisat
eur application et l'interface créée, permet à la fois de faciliter l'utilisatio
n de notre système par le programmeur mais aussi d'établir un cadre sûr
 pour les les dites interactions.
 La partie 3.1 de ce rapport est un exemple de ce principe.
\end_layout

\end_deeper
\begin_layout Subsection
Division du travail
\end_layout

\begin_layout Standard
La conception d'une interface graphique par dessus un moteur d'application
 peut se diviser en quatre étapes ; une bibliothèque graphique devrait fournir
 des outils adéquats pour chacune, et minimiser les interdépendances entre
 elles.
\end_layout

\begin_layout Paragraph
Communication entre le moteur et l'interface
\end_layout

\begin_layout Standard
Une bibliothèque graphique doit fournir des outils adaptées à la 
\begin_inset Quotes fld
\end_inset

communication
\begin_inset Quotes frd
\end_inset

 entre l'interface et le moteur logique de l'application
\end_layout

\begin_layout Itemize
affichage : ensemble des données du moteur affichées (sous diverses formes)
 par l'interface ;
\end_layout

\begin_layout Itemize
actions : ensemble des actions de l'utilisateur modifiant l'état des données.
 
\end_layout

\begin_layout Standard
Cette partie du code pose les bases de ce qu'utilisera l'interface, ce à
 quoi elle est destinée, mais doit demeurer indépendante de son implémentation
 réelle, des éléments graphiques concrets utilisés pour la fabriquer, et
 de la plateforme à laquelle elle est destinée.
\end_layout

\begin_layout Paragraph
Éléments de l'interface
\end_layout

\begin_layout Standard
Il s'agit ensuite de définir les éléments de l'interface graphique qui serviront
 de support aux données et possibilités définis précédemment ; ceux-ci devront
 donc interagir avec le système logique de communication, et non directement
 avec le moteur de l'application.
\end_layout

\begin_layout Standard
Ils sont évidemment dépendants de la plateforme à laquelle l'interface est
 destinée : les raccourcis clavier d'un ordinateur seront remplacés par
 des gestes tactiles sur une tablette, par exemple.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La bibliothèque se doit de définir un panel aussi vaste que possible d'éléments
 graphique à disposition du développeur.
\end_layout

\begin_layout Standard
Notons que ces éléments ne sont pas forcément tous graphiques (lecture d'un
 texte ou commande vocale).
\end_layout

\begin_layout Paragraph
Placement des éléments
\end_layout

\begin_layout Standard
Les éléments doivent ensuite être assemblés pour former une interface cohérente
 et fonctionnelle.
 À cette fin, de nombreux outils doivent être présents pour le développeur
 : divers 
\begin_inset Quotes fld
\end_inset

layout
\begin_inset Quotes frd
\end_inset

 permettant diverses dispositions des éléments au sein d'une même fenêtre,
 gestion intelligente des redimensionnements, système d'onglets, éléments
 permettant le zoom et défilement, fenêtres pop-up, panneaux d'options,
 etc.
\end_layout

\begin_layout Standard
Une telle configuration s'effectue évidemment sur un ensemble d'éléments
 de l'interface déjà défini, dont la taille et l'aspect graphique doivent
 également pouvoir être éventuellement personnalisés au cas par cas.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Par ailleurs, le développeur peut laisser une partie de cette configuration
 de l'interface à disposition de l'utilisateur final : lui permettre de
 choisir les éléments présents d'une barre d'outils, ou le placement de
 celle-ci sur certains bords de la fenêtre, tout en excluant certaines autres
 modifications, le menu restant toujours identique.
\end_layout

\begin_layout Standard
Enfin, la forme finale d'une interface doit pouvoir être aisément enregistrée,
 et il doit être possible pour l'utilisateur final de passer d'une configuration
 à une autre s'il en existe plusieurs possibles pour une application donnée.
\end_layout

\begin_layout Paragraph
Aspect général
\end_layout

\begin_layout Standard
Enfin, la bibliothèque peut permettre au développeur de modifier l'aspect
 général de son interface, en personnalisant l'aspect d'un type d'éléments
 graphiques.
 Cette dernière partie est optionnel, mais si la possibilité existe, elle
 doit être indépendante des trois premières : modifier l'aspect général
 des boutons ne doit pas impacter le code de l'interface déjà écrite.
\end_layout

\begin_layout Section
Analyse de l'existant
\end_layout

\begin_layout Standard
Analyse de Swing / GTK (qui ont évidement des problèmes insurmontables)
 ainsi que du couple HTML CSS et le concept intéressant de la séparation
 du style de la déclaration des objets.
\end_layout

\begin_layout Section
Outils à développer
\end_layout

\begin_layout Subsection
Actions
\end_layout

\begin_layout Standard
Une librairie graphique se doit de fournir une représentation des 
\emph on
actions
\emph default
 que l'utilisateur peut accomplir.
 Fondamentalement, il s'agit d'une fonction qui a accès au moteur de l'applicati
on, contrairement à l'interface proprement dite, mais d'autres mécanismes
 internes s'y greffent.
\end_layout

\begin_layout Standard
Ces 
\emph on
actions
\emph default
 sont indépendantes des éléments graphiques concrets qui l'implémentent,
 et donc en particulier de la plateforme sur laquelle tourne l'interface
 utilisateur.
\end_layout

\begin_layout Standard
Toute intervention de l'utilisateur final sur le système de l'application
 doit passer par une 
\emph on
action
\emph default
 telle que définie par la librairie.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Deux principes nous guident :
\end_layout

\begin_layout Itemize
La façon dont l'utilisateur accomplit cette action n'a aucune importance
 ; l'action n'a pas besoin de savoir qu'elle a été déclenchée par un bouton,
 une entrée de menu, un raccourci clavier, une commande vocale, ou même
 comme conséquence automatique d'une autre action.
\end_layout

\begin_layout Itemize
Tous les paramètres des éléments graphiques liés à une action doivent être
 
\begin_inset Quotes fld
\end_inset

transférés
\begin_inset Quotes frd
\end_inset

 à l'action si possible, tels que :
\end_layout

\begin_deeper
\begin_layout Itemize
les raccourcis claviers, noms, descriptions, textes d'aide ou icônes associés
 à une action ;
\end_layout

\begin_layout Itemize
la possibilité d'accomplir l'action (qui déterminera si le bouton ou l'entrée
 de menu sont actifs ou non, par exemple).
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Ce mécanisme d'action fourni par la librairie graphique doit être doté d'un
 pattern 
\begin_inset Quotes fld
\end_inset

observer
\begin_inset Quotes frd
\end_inset

, permettant à d'autres éléments d'être notifié du déclenchement de l'action.
\end_layout

\begin_layout Standard
Les actions doivent pouvoir être aisément composées, afin de permettre au
 développeur de n’implémenter que les interactions minimales avec son système,
 tout en proposant à l'utilisateur final des fonctionnalités simples autant
 qu'avancés, résultant éventuellement de combinaisons complexes de ces briques
 de base.
\end_layout

\begin_layout Standard
Enfin, les actions effectuées doivent pouvoir être enregistrées, afin d'en
 conserver un historique.
 Idéalement, si chaque action dispose également d'une fonction 
\begin_inset Quotes fld
\end_inset

inverse
\begin_inset Quotes frd
\end_inset

 permettant d'annuler ses effets, la bibliothèque graphique peut fournir
 elle-même la fonctionnalité 
\begin_inset Quotes fld
\end_inset

undo / redo
\begin_inset Quotes frd
\end_inset

, aujourd'hui devenue indispensable à toute interface moderne.
\end_layout

\begin_layout Subsection
Bindings
\end_layout

\begin_layout Standard
Très souvent, l'intervention de l'utilisateur modifie des valeurs internes
 au moteur de l'application ; parfois néanmoins, l'inverse peut être également
 utile : la modification d'une valeur du moteur de l'application modifie
 l'état d'un élément de l'interface.
 Il s'agit alors de modéliser efficacement la liaison d'une propriété d'un
 élément graphique à une valeur de la logique interne de l'application.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Voici quelques exemples qui pourraient se révéler utiles au développement
 d'une interface :
\end_layout

\begin_layout Itemize
progression d'une opération affichée par une barre de progression ;
\end_layout

\begin_layout Itemize
possibilité d'effectuer une action liée à un booléen, impliquant l'apparence
 des éléments graphiques qui lui sont liés (actifs ou non) ;
\end_layout

\begin_layout Itemize
champs d'un label liée à une chaîne de caractère, position d'un curseur
 liée à une valeur numérique ;
\end_layout

\begin_layout Itemize
contenu d'un panneau lié à une image dynamiquement déterminée par le moteur
 applicatif.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Si l’élément graphique peut être édité par l'utilisateur, la liaison doit
 être effective dans les deux sens : le changement du champs du label par
 l'utilisateur doit modifier la valeur de la chaîne de caractère en interne,
 tout autre changement de la valeur doit être immédiatement répercuté dans
 l'affichage, comme dans le cas de la barre d'url des navigateurs internet
 (qui est évidemment actualisé en cas de redirection, ou si l'utilisateur
 utilise un autre moyen pour parvenir sur un page web).
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
À cette fin, la librairie graphique peut proposer des représentations des
 types simples 
\begin_inset Quotes fld
\end_inset

pertinents
\begin_inset Quotes frd
\end_inset

 comprenant un pattern observer à destination des éléments de l'interface
 ; la liaison d'une propriété graphique à la valeur deviendrait alors immédiate
 et transparente pour le développeur.
 
\end_layout

\begin_layout Standard
L'inconvénient est que le moteur de l'application doit alors utiliser la
 librairie graphique pour implémenter de telles valeurs.
\end_layout

\begin_layout Subsection
Le modèle relationnel
\end_layout

\begin_layout Standard
Les différents élément d'une interface utilisateur doivent être mis en relation
 les uns avec les autres afin de former un tout cohérent.
 Le principe le plus basique, qui est celui du modèle à widget évoqué dans
 la partie 2, est de ne considérer qu'une seule relation : la relation de
 parenté entre le contenant et le contenu.
\end_layout

\begin_layout Standard
Il serait cependant intéressant de pouvoir définir plus finement les relations
 entre ces différents éléments, plus précisément, l'idée serait de ne pas
 avoir à décrire l'emplacement d'un élément par rapport à un autre, mais
 plutôt les relations entre ces éléments, un peu à la manière du couple
 HTML / CSS.
\end_layout

\begin_layout Standard
Un premier exemple de relation autre qu'une relation de parenté est la relation
 
\begin_inset Quotes fld
\end_inset

menu
\begin_inset Quotes frd
\end_inset

 qui est, à un niveau basique, présente dans Swing : pour certains éléments
 il est possible de définir un menu sans avoir à spécifier que ce dernier
 est contenu dans l'élément demandeur.
 Il y a une relation de 
\begin_inset Quotes fld
\end_inset

menu
\begin_inset Quotes frd
\end_inset

 entre ces deux éléments et non une relation directe de positionnement.
\end_layout

\begin_layout Standard
Ce modèle a pour but de permettre à l'interface produite de s'adapter à
 son environnement d'utilisation.
 De plus, une analyse statique de la cohérence d'une interface pourrait
 certainement se faire à partir d'un tel modèle (réflexion en cours).
\end_layout

\begin_layout Subsection
Langages intermédiaires
\end_layout

\begin_layout Standard
Le système a vocation à être porté sur différents langages de programmation;
 l'utilisation de langages intermédiaires, propres au dit système, permet
 entre autre une portabilité intéressante.
 Deux langages intermédiaires sont introduit à cet effet :
\end_layout

\begin_layout Itemize
Style de l'interface : notre solution à base de modèle relationnel doit
 être complétée, afin d'obtenir l'adaptativité recherchée, d'une déclaration
 de style dont le rôle est de traduire les relations entre les composants
 en une présentation graphique adaptée au support.
 Ceci nécessite d'une part l'élaboration d'un langage intermédiaire servant
 à décrire cette traduction et d'autre part la réalisation d'un interpréteur
 du dit langage.
 L'utilisation d'une telle architecture permet à la fois d'avoir un comportement
 par défaut propre à chaque support, mais peut aussi permettre au programmeur
 d’établir une charte graphique pour toutes ses applications, et ce sans
 avoir à s'en préoccuper à chaque nouveau projet.
\end_layout

\begin_layout Itemize
Structure de l'interface : une autre volonté de notre part est de permettre
 la sauvegarde de la structure d'une interface.
 Avoir une description de ladite structure non liée à langage source permet
 une réutilisation intéressante sur différents projets.
 La difficulté d'une telle représentation se situe au niveau des interactions
 entre le moteur de l'application et l'interface utilisateur, cependant
 le modèle d'actions est adapté à cette démarche (cette partie est encore
 floue, nous sommes encore en phase de réflexion quant à la faisabilité
 et la pertinence de la chose).
\end_layout

\end_body
\end_document
