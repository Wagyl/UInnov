#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 2cm
\headsep 2cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part*
Notes en vrac
\end_layout

\begin_layout Itemize
Swing / GTK / QT reposent sur un modèle de 
\begin_inset Quotes eld
\end_inset

widgets
\begin_inset Quotes erd
\end_inset

 - des boites dans des boites qui forment des boites qu'on peut remettre
 dans des boites - avec une expressivité 
\begin_inset Quotes eld
\end_inset

bas niveau
\begin_inset Quotes erd
\end_inset

.
 On définit 
\begin_inset Quotes eld
\end_inset

à la main
\begin_inset Quotes erd
\end_inset

 l'emplacement des différents éléments -> c'est naze.
\end_layout

\begin_layout Itemize
Une interface créée à l'aide de Swing / GTK / QT offre la possibilité d'adapter
 son aspect visuel à l'OS hôte (sans avoir à changer le code) -> intéressant.
\end_layout

\begin_layout Itemize
Swing / GTK / QT n'offrent pas une 
\begin_inset Quotes eld
\end_inset

portabilité
\begin_inset Quotes erd
\end_inset

 pour les interfaces créées : il n'est pas aisé de transporter une interface
 d'une appli à une autre sans avoir à beaucoup toucher au code -> peut-être
 intéressant ?
\end_layout

\begin_layout Itemize
Toujours sur la 
\begin_inset Quotes eld
\end_inset

portabilité
\begin_inset Quotes erd
\end_inset

 : Swing n'offre pas un langage intermédiaire indépendant des bindings pour
 différents langages hôtes.
 GTK offre une description XML des interfaces (à vérifier) -> concept intéressan
t.
 Quid de QT ?
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Portabilité / adptativité
\begin_inset Quotes erd
\end_inset

 : les interfaces créées via Swing / GTK / QT ne s'adaptent pas automatiquement
 au support matériel : clavier / souris, écran tactile, quelle taille d'écran
 ...
 c'est naze !
\end_layout

\begin_layout Itemize
HTML / CSS offre justement cette approche, cependant des problèmes se posent
 dans le cas HTML / CSS : les différents navigateurs interprêtent de manières
 assez différentes les styles, est-ce un problème ?
\end_layout

\begin_layout Itemize
Bien que n'étant pas fait pour la création d'interfaces graphiques dans
 des applications autre que web, le couple HTML / CSS a une approche intéressant
e : séparer le style de la description des éléments.
\end_layout

\begin_layout Itemize
Swing / GTK n'offrent à priori aucune analyse statique de 
\begin_inset Quotes eld
\end_inset

débilité
\begin_inset Quotes erd
\end_inset

 d'une interface : des éléments toujours invisibles / non atteignables etc
 etc ...
\end_layout

\begin_layout Itemize
Swing est une horreur à débugger, quid de GTK / QT ?
\end_layout

\begin_layout Itemize
Swing est très verbeux, quid de GTK / QT ?
\end_layout

\begin_layout Itemize
Quid des performances de Swing / GTK / QT ?
\end_layout

\begin_layout Itemize
La gestion des actions est nulle dans Swing : verbeuse, assez peu intuitive.
 Quid de GTK / QT ?
\end_layout

\begin_layout Itemize
A compléter ...
 les idées sont à fouttre en vrac, il faudra trier ensuite.
\end_layout

\begin_layout Itemize
Interface résultante modelable par l'utilisateur.
\end_layout

\begin_layout Itemize
Debugging aisé pour le programmeur.
\end_layout

\begin_layout Itemize
etc etc ...
\end_layout

\begin_layout Section
Qu'est ce qu'une interface utilisateur et comment en programmer
\end_layout

\begin_layout Subsection
Définition des concepts liés à la notion d'interface utilisateur
\end_layout

\begin_layout Subsubsection*
Qui sont les utilisateurs ?
\end_layout

\begin_layout Itemize
Deux catégories : nous utiliserons suivante afin de distinguer les deux
 catégories d'utilisateurs : utilisateur application, et programmeur.
\end_layout

\begin_layout Itemize
Dans les deux cas, il faut avoir une approche orientée utilisateur, les
 besoins seront différents, mais l'approche à adopter la même.
 
\end_layout

\begin_layout Itemize
Utilisateur application : il faut prendre en compte à la fois l'aspect sensoriel
 (visuel si écran il y a) et l'aspect 
\begin_inset Quotes eld
\end_inset

contrôle
\begin_inset Quotes erd
\end_inset

 (gestion des périphériques d'entrée).
\end_layout

\begin_layout Itemize
Intéraction utilisateur application - programme : plusieurs 
\begin_inset Quotes eld
\end_inset

niveaux
\begin_inset Quotes erd
\end_inset

 de compétences parmi les utilisateurs avec des besoins différents.
\end_layout

\begin_layout Subsubsection*
Conception - génie logiciel
\end_layout

\begin_layout Standard
Utilisation de la conception centrée utilisateur qui est un modèle itératif.
\end_layout

\begin_layout Itemize

\series bold
Analyse :
\series default
 analyse des besoins, un panel représentatif d'utilisateurs des deux catégories
 concernées doit être constitué afin d'établir les dits besoins.
\end_layout

\begin_layout Itemize

\series bold
Conception :
\series default
 un prototype doit être conçu en fonction des besoins établis à l'étape
 précédente.
\end_layout

\begin_layout Itemize

\series bold
Evaluation :
\series default
 sur la base du prototype réalisé, une évaluation est faite.
 Le procédé étant itératif, cette évaluation servira de base à la modification
 des besoins de la première étape.
 
\end_layout

\begin_layout Itemize
Il faut établir des 
\begin_inset Quotes eld
\end_inset

topic
\begin_inset Quotes erd
\end_inset

 d'évaluation - besoins, les deux sont liés : 
\end_layout

\begin_deeper
\begin_layout Itemize
Pour l'utilisateur application :
\end_layout

\begin_deeper
\begin_layout Itemize
Vitesse d'apprentissage - aide nécessaire / intégrée - nombre d'erreurs
 commises lors d'un test.
\end_layout

\begin_layout Itemize
Correction des erreurs.
\end_layout

\begin_layout Itemize
Temps de réponse.
\end_layout

\begin_layout Itemize
Efficacité - navigation rapide ?
\end_layout

\end_deeper
\begin_layout Itemize
Pour le programmeur :
\end_layout

\begin_deeper
\begin_layout Itemize
Programmation intuitive.
\end_layout

\begin_layout Itemize
Bonne expressivité - ne pas avoir un code verbeux à produire (capacité d'adaptat
ion au support etc etc ?).
\end_layout

\begin_layout Itemize
Typage fort - sûreté.
\end_layout

\begin_layout Itemize
Debugging aisé - analyse de pertinence (détecter le maximum d'absurdités)
\end_layout

\begin_layout Itemize
Intégration aux IDE populaires ? Création d'un IDE ?
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Les outils : 
\series default
des outils du génie logiciel peuvent nous aider à l'intérieur des phases
 décrites précédement :
\end_layout

\begin_deeper
\begin_layout Itemize
Scénarios / diagrammes de cas d'utilisation : à la fois pour établir les
 besoins et faire l'évaluation au niveau de l'utilisateur application.
 Peut aussi être utilisé pour le côté programmeur bien que le point suivant
 me semble être plus approprié.
\end_layout

\begin_layout Itemize
Diagrammes relationnels - diagrammes de classes : relations entre les différents
 objets de l'interface, est utile dans la phase de conception pour 
\begin_inset Quotes eld
\end_inset

se mettre à la place
\begin_inset Quotes erd
\end_inset

 du programmeur.
\end_layout

\begin_layout Itemize
Design pattern : beaucoup d'interfaces utilisateurs utilisent des principes
 similaires d'intéraction avec l'utilisateur, l'implémentation 
\begin_inset Quotes eld
\end_inset

native
\begin_inset Quotes erd
\end_inset

 de comportements génériques peut être pratique.
\end_layout

\end_deeper
\end_body
\end_document
